# [Gold IV] 최단경로 - 1753 

[문제 링크](https://www.acmicpc.net/problem/1753) 

### 분류

그래프 이론, 최단 경로, 데이크스트라

### 문제 설명

<p>방향그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램을 작성하시오. 단, 모든 간선의 가중치는 10 이하의 자연수이다.</p>

### 입력 

 <p>첫째 줄에 정점의 개수 V와 간선의 개수 E가 주어진다. (1 ≤ V ≤ 20,000, 1 ≤ E ≤ 300,000) 모든 정점에는 1부터 V까지 번호가 매겨져 있다고 가정한다. 둘째 줄에는 시작 정점의 번호 K(1 ≤ K ≤ V)가 주어진다. 셋째 줄부터 E개의 줄에 걸쳐 각 간선을 나타내는 세 개의 정수 (u, v, w)가 순서대로 주어진다. 이는 u에서 v로 가는 가중치 w인 간선이 존재한다는 뜻이다. u와 v는 서로 다르며 w는 10 이하의 자연수이다. 서로 다른 두 정점 사이에 여러 개의 간선이 존재할 수도 있음에 유의한다.</p>

### 출력 

 <p>첫째 줄부터 V개의 줄에 걸쳐, i번째 줄에 i번 정점으로의 최단 경로의 경로값을 출력한다. 시작점 자신은 0으로 출력하고, 경로가 존재하지 않는 경우에는 INF를 출력하면 된다.</p>



#  🚀  오답노트 

```diff
import java.util.*;
import java.io.*;

-class Node {
+class Node implements Comparable<Node>{
    
    private int index;
    private int distance;
    
    public Node(int index, int distance){
        this.index = index;
        this.distance = distance;
    }
    
    public int getIndex(){
        return this.index;
    }
    public int getDistance(){
        return this.distance;
    }
+    
+    @Override
+    public int compareTo(Node other){
+        // return this.distance - other.distance;
+        return Integer.compare(this.distance, other.distance);
+    }
}

public class Main {
    
    public static final int INF = (int) 1e9;
    public static ArrayList<ArrayList<Node>> graph = new ArrayList<ArrayList<Node>>();
    public static boolean visited[] = new boolean[100001];
    public static int d[] = new int[100001];
    public static int V, E;
-        
-    //방문하지 않은 노드 중에서 거리가 제일 짧은 노드의 인덱스 반환 
-    public static int getSmallestNode(){
-        int min = INF;
-        int index = 0;
-        visited[index] = true;
-        for(int i=1; i<=V; i++){
-            if(d[i] < min && !visited[i]){
-                min = d[i];
-                index = i;
-            }
-        }
-        return index;
-    }
    
    public static void dijkstra(int start){
-        //시작 노드 초기화 - d 초기화도 필요한가?
+    
+        // PriorityQueue<Node> pq = new PriorityQueue<>((o1, o2) -> o1.distance - o2.distance);
+        PriorityQueue<Node> pq = new PriorityQueue<>();
+        pq.offer(new Node(start, 0));   //시작점 자신은 0으로 출력하기 
        d[start] = 0;
-        visited[start] = true;
-        for(int i=0; i<graph.get(start).size(); i++){
-            d[graph.get(start).get(i).getIndex()] = graph.get(start).get(i).getDistance();
-        }
-        
-        //시작 노드를 제외한 나머지
-        for(int i=0; i<V-1; i++){
-            int now = getSmallestNode();
-            visited[now] = true;
+        while(!pq.isEmpty()){
+
+            //최단거리 정보 꺼내기 
+            Node node = pq.poll();
+            int now = node.getIndex();
+            int dis = node.getDistance();
+            if(d[now] < dis) continue;   //이미 처리된 적 있다면 컨티뉴 이렇게???
+                
            for(int j=0; j<graph.get(now).size(); j++){
                //거리 비교, cost에 d[now]잊지 말기 
+                int otherIndex = graph.get(now).get(j).getIndex();
                int cost = d[now] + graph.get(now).get(j).getDistance();
-                if(cost < d[graph.get(now).get(j).getIndex()]){
-                    d[graph.get(now).get(j).getIndex()] = cost;
+                if(cost < d[otherIndex]){
+                    d[otherIndex] = cost;
+                    //pq에도 cost갱신
+                    pq.offer(new Node(otherIndex, cost));
                }
            }
        }
+        
    }
    
    
    public static void main(String[] args) throws IOException {
        
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        V = Integer.parseInt(st.nextToken());
        E = Integer.parseInt(st.nextToken());
        int start = Integer.parseInt(br.readLine());
        
        //그래프 초기화 (노드는 1부터 V개임, <=V임을 잊지말것)
        for(int i=0; i<=V; i++){
            graph.add(new ArrayList<Node>());
        }
        
        for(int i=0; i<E; i++){
            st = new StringTokenizer(br.readLine(), " ");
            int u = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());
            int w = Integer.parseInt(st.nextToken());
            graph.get(u).add(new Node(v, w));
        }
        
        Arrays.fill(d, INF);
        dijkstra(start);
        
        StringBuilder sb = new StringBuilder(); 
-        for(int i=0; i<=V; i++){
-            if(i == start){
-                sb.append("0\n");
-            } else if(d[i] == INF){
-                sb.append("INF\n");
+        for(int i=1; i<=V; i++){
+            if(d[i] == INF){
+                // sb.append("INF\n");
+                System.out.println("INF");
            } else {
-                sb.append(d[i]).append("\n");
+                // sb.append(d[i]).append("\n");
+                System.out.println(d[i]);
            }
        }
-        System.out.println(sb);
+        // System.out.println(sb);
    }
}

```

# 💻 코드 리뷰




 ## 🏆 메모 

이 문제는 다익스트라를 사용하는 골드 4 문제이다.
- 이 풀이는 4번을 틀리면서 완성될 수 있었다.... 여러 포인트가 있었는데, 차근 차근 말해보겠다.
- 동빈나 풀이는 ArrayList<ArrayList<Integer> graph이런식으로 사용한다. 최근 블로그 풀이에선, ArrayList<Node> graph로 정의해두고 배열 초기화 때 graph[i] = new ArrayList<>(); 이런식으로 진행하더라. (취향 차이인듯)
- 어떤 풀이에선 스트림 문법으로 Comparator을 아주 쉽게 쓰기도 했다. PriorityQueue<Node> pq = new PriorityQueue<>((o1, o2) -> o1.distance - o2.distance); 
- 근데 이렇게 하면 단점이 있는게, 다른 클래스 안의 변수는 보통 private으로 하기에(캡슐화, 은닉) 나의 경우에는 사용하지 않았다. 그치만 훨씬 깔끔하고 좋았다
- while 반복문 내에서 if(d[now] < dis) continue; 을 넣어 성능을 확보할 수 있었다. (PriorityQueue는 큐에 들어온 시점에서의 거리 기준으로 정렬만 함. 나중에 더 짧은 거리로 갱신될 수 있음)
